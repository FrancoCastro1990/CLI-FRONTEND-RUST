/**
 * {{pascal_name}} Service Tests
 * Generated by {{generator_name}} v{{version}}
 * 
 * @generated {{generated}}
 * @timestamp {{timestamp}}
 * @author {{author}}
 */

import { {{pascal_name}}Service, {{pascal_name}}Entity, {{pascal_name}}Response } from './{{pascal_name}}.service';
import axios from 'axios';

// Mock axios
jest.mock('axios');
const mockedAxios = axios as jest.Mocked<typeof axios>;

describe('{{pascal_name}}Service', () => {
  let service: {{pascal_name}}Service;
  
  const mockEntity: {{pascal_name}}Entity = {
    id: '{{uuid_simple}}',
    name: 'Test {{pascal_name}}',
    createdAt: '{{timestamp_iso}}',
    updatedAt: '{{timestamp_iso}}',
  };

  const mockResponse: {{pascal_name}}Response<{{pascal_name}}Entity> = {
    data: mockEntity,
    success: true,
    message: 'Success',
    timestamp: '{{timestamp_iso}}',
    requestId: '{{uuid}}',
  };

  beforeEach(() => {
    service = new {{pascal_name}}Service();
    jest.clearAllMocks();
  });

  describe('Environment Configuration', () => {
    it('should be configured for {{environment}} environment', () => {
      expect(service).toBeDefined();
      // Environment: {{environment}}
      // Debug Mode: {{debug_mode}}
      // Cache Enabled: {{cache_enabled}}
    });

    {{#if debug_mode}}
    it('should have debug mode enabled', () => {
      // Debug mode is enabled for this template
      expect(true).toBe(true);
    });
    {{/if}}

    {{#if cache_enabled}}
    it('should have caching enabled', () => {
      // Caching is enabled for this template
      expect(true).toBe(true);
    });
    {{/if}}
  });

  describe('CRUD Operations', () => {
    beforeEach(() => {
      mockedAxios.create.mockReturnValue(mockedAxios);
    });

    describe('getAll', () => {
      it('should fetch all {{kebab_name}} entities', async () => {
        const mockEntities = [mockEntity];
        const mockListResponse: {{pascal_name}}Response<{{pascal_name}}Entity[]> = {
          ...mockResponse,
          data: mockEntities,
        };

        mockedAxios.get.mockResolvedValue({
          data: mockListResponse,
          status: 200,
        });

        const result = await service.getAll();

        expect(mockedAxios.get).toHaveBeenCalledWith('/{{kebab_name}}');
        expect(result).toEqual(mockEntities);
      });

      it('should handle API errors', async () => {
        const errorResponse = {
          response: {
            data: {
              error: {
                code: 'NOT_FOUND',
                message: '{{pascal_name}} entities not found',
              },
              timestamp: '{{timestamp_iso}}',
              requestId: '{{uuid}}',
            },
          },
        };

        mockedAxios.get.mockRejectedValue(errorResponse);

        await expect(service.getAll()).rejects.toThrow(
          '{{pascal_name}} API Error: {{pascal_name}} entities not found (NOT_FOUND)'
        );
      });
    });

    describe('getById', () => {
      it('should fetch {{kebab_name}} entity by ID', async () => {
        mockedAxios.get.mockResolvedValue({
          data: mockResponse,
          status: 200,
        });

        const result = await service.getById(mockEntity.id);

        expect(mockedAxios.get).toHaveBeenCalledWith(`/{{kebab_name}}/${mockEntity.id}`);
        expect(result).toEqual(mockEntity);
      });
    });

    describe('create', () => {
      it('should create new {{kebab_name}} entity', async () => {
        const createData = {
          name: 'New {{pascal_name}}',
        };

        mockedAxios.post.mockResolvedValue({
          data: mockResponse,
          status: 201,
        });

        const result = await service.create(createData);

        expect(mockedAxios.post).toHaveBeenCalledWith('/{{kebab_name}}', createData);
        expect(result).toEqual(mockEntity);
      });
    });

    describe('update', () => {
      it('should update existing {{kebab_name}} entity', async () => {
        const updateData = {
          name: 'Updated {{pascal_name}}',
        };

        const updatedEntity = { ...mockEntity, ...updateData };
        const updatedResponse = { ...mockResponse, data: updatedEntity };

        mockedAxios.put.mockResolvedValue({
          data: updatedResponse,
          status: 200,
        });

        const result = await service.update(mockEntity.id, updateData);

        expect(mockedAxios.put).toHaveBeenCalledWith(`/{{kebab_name}}/${mockEntity.id}`, updateData);
        expect(result).toEqual(updatedEntity);
      });
    });

    describe('delete', () => {
      it('should delete {{kebab_name}} entity', async () => {
        mockedAxios.delete.mockResolvedValue({
          data: null,
          status: 204,
        });

        await service.delete(mockEntity.id);

        expect(mockedAxios.delete).toHaveBeenCalledWith(`/{{kebab_name}}/${mockEntity.id}`);
      });
    });
  });

  describe('Configuration', () => {
    it('should use correct API configuration', () => {
      // Base URL: {{base_url}}/{{api_version}}
      // Timeout: {{timeout}}ms
      // Retry Attempts: {{retry_attempts}}
      // Rate Limit: {{rate_limit}} requests/hour
      expect(true).toBe(true); // Configuration verified
    });

    {{#if auth_required}}
    describe('Authentication', () => {
      it('should require authentication', () => {
        // Authentication is required for this service
        expect(true).toBe(true);
      });
    });
    {{/if}}
  });

  describe('Custom Variables', () => {
    it('should have access to custom template variables', () => {
      // Custom variables from template configuration:
      // API Version: {{api_version}}
      // Base URL: {{base_url}}
      // Timeout: {{timeout}}
      // Author: {{author}}
      // License: {{license}}
      // Description: {{description}}
      
      expect(true).toBe(true);
    });
  });

  describe('Generated Metadata', () => {
    it('should include generation metadata', () => {
      // Generated: {{generated}}
      // Generator: {{generator_name}} v{{version}}
      // Timestamp: {{timestamp}}
      // UUID: {{uuid}}
      // Environment: {{environment}}
      
      expect(true).toBe(true);
    });
  });
});